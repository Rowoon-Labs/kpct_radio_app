// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'decomposition.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

Decomposition _$DecompositionFromJson(Map<String, dynamic> json) {
  return _Decomposition.fromJson(json);
}

/// @nodoc
mixin _$Decomposition {
  String get id => throw _privateConstructorUsedError;
  @JsonKey(name: "gear_ID")
  String get gearId => throw _privateConstructorUsedError;
  @StringToIntConverter()
  @JsonKey(name: "cost_EP")
  int get costEp => throw _privateConstructorUsedError;
  @StringToIntConverter()
  @JsonKey(name: "cost_SSP")
  int get costSsp => throw _privateConstructorUsedError;
  @StringToIntConverter()
  @JsonKey(name: "result_max")
  int get resultMax => throw _privateConstructorUsedError;
  @StringToIntConverter()
  @JsonKey(name: "result_min")
  int get resultMin => throw _privateConstructorUsedError;
  @JsonKey(name: "result1")
  String? get result1 => throw _privateConstructorUsedError;
  @JsonKey(name: "result2")
  String? get result2 => throw _privateConstructorUsedError;
  @JsonKey(name: "result3")
  String? get result3 => throw _privateConstructorUsedError;
  @JsonKey(name: "result4")
  String? get result4 => throw _privateConstructorUsedError;
  @JsonKey(name: "result5")
  String? get result5 => throw _privateConstructorUsedError;
  @JsonKey(name: "result6")
  String? get result6 => throw _privateConstructorUsedError;
  @JsonKey(name: "result7")
  String? get result7 => throw _privateConstructorUsedError;
  @JsonKey(name: "result8")
  String? get result8 => throw _privateConstructorUsedError;

  /// Serializes this Decomposition to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Decomposition
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DecompositionCopyWith<Decomposition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DecompositionCopyWith<$Res> {
  factory $DecompositionCopyWith(
    Decomposition value,
    $Res Function(Decomposition) then,
  ) = _$DecompositionCopyWithImpl<$Res, Decomposition>;
  @useResult
  $Res call({
    String id,
    @JsonKey(name: "gear_ID") String gearId,
    @StringToIntConverter() @JsonKey(name: "cost_EP") int costEp,
    @StringToIntConverter() @JsonKey(name: "cost_SSP") int costSsp,
    @StringToIntConverter() @JsonKey(name: "result_max") int resultMax,
    @StringToIntConverter() @JsonKey(name: "result_min") int resultMin,
    @JsonKey(name: "result1") String? result1,
    @JsonKey(name: "result2") String? result2,
    @JsonKey(name: "result3") String? result3,
    @JsonKey(name: "result4") String? result4,
    @JsonKey(name: "result5") String? result5,
    @JsonKey(name: "result6") String? result6,
    @JsonKey(name: "result7") String? result7,
    @JsonKey(name: "result8") String? result8,
  });
}

/// @nodoc
class _$DecompositionCopyWithImpl<$Res, $Val extends Decomposition>
    implements $DecompositionCopyWith<$Res> {
  _$DecompositionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Decomposition
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? gearId = null,
    Object? costEp = null,
    Object? costSsp = null,
    Object? resultMax = null,
    Object? resultMin = null,
    Object? result1 = freezed,
    Object? result2 = freezed,
    Object? result3 = freezed,
    Object? result4 = freezed,
    Object? result5 = freezed,
    Object? result6 = freezed,
    Object? result7 = freezed,
    Object? result8 = freezed,
  }) {
    return _then(
      _value.copyWith(
            id:
                null == id
                    ? _value.id
                    : id // ignore: cast_nullable_to_non_nullable
                        as String,
            gearId:
                null == gearId
                    ? _value.gearId
                    : gearId // ignore: cast_nullable_to_non_nullable
                        as String,
            costEp:
                null == costEp
                    ? _value.costEp
                    : costEp // ignore: cast_nullable_to_non_nullable
                        as int,
            costSsp:
                null == costSsp
                    ? _value.costSsp
                    : costSsp // ignore: cast_nullable_to_non_nullable
                        as int,
            resultMax:
                null == resultMax
                    ? _value.resultMax
                    : resultMax // ignore: cast_nullable_to_non_nullable
                        as int,
            resultMin:
                null == resultMin
                    ? _value.resultMin
                    : resultMin // ignore: cast_nullable_to_non_nullable
                        as int,
            result1:
                freezed == result1
                    ? _value.result1
                    : result1 // ignore: cast_nullable_to_non_nullable
                        as String?,
            result2:
                freezed == result2
                    ? _value.result2
                    : result2 // ignore: cast_nullable_to_non_nullable
                        as String?,
            result3:
                freezed == result3
                    ? _value.result3
                    : result3 // ignore: cast_nullable_to_non_nullable
                        as String?,
            result4:
                freezed == result4
                    ? _value.result4
                    : result4 // ignore: cast_nullable_to_non_nullable
                        as String?,
            result5:
                freezed == result5
                    ? _value.result5
                    : result5 // ignore: cast_nullable_to_non_nullable
                        as String?,
            result6:
                freezed == result6
                    ? _value.result6
                    : result6 // ignore: cast_nullable_to_non_nullable
                        as String?,
            result7:
                freezed == result7
                    ? _value.result7
                    : result7 // ignore: cast_nullable_to_non_nullable
                        as String?,
            result8:
                freezed == result8
                    ? _value.result8
                    : result8 // ignore: cast_nullable_to_non_nullable
                        as String?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$DecompositionImplCopyWith<$Res>
    implements $DecompositionCopyWith<$Res> {
  factory _$$DecompositionImplCopyWith(
    _$DecompositionImpl value,
    $Res Function(_$DecompositionImpl) then,
  ) = __$$DecompositionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    @JsonKey(name: "gear_ID") String gearId,
    @StringToIntConverter() @JsonKey(name: "cost_EP") int costEp,
    @StringToIntConverter() @JsonKey(name: "cost_SSP") int costSsp,
    @StringToIntConverter() @JsonKey(name: "result_max") int resultMax,
    @StringToIntConverter() @JsonKey(name: "result_min") int resultMin,
    @JsonKey(name: "result1") String? result1,
    @JsonKey(name: "result2") String? result2,
    @JsonKey(name: "result3") String? result3,
    @JsonKey(name: "result4") String? result4,
    @JsonKey(name: "result5") String? result5,
    @JsonKey(name: "result6") String? result6,
    @JsonKey(name: "result7") String? result7,
    @JsonKey(name: "result8") String? result8,
  });
}

/// @nodoc
class __$$DecompositionImplCopyWithImpl<$Res>
    extends _$DecompositionCopyWithImpl<$Res, _$DecompositionImpl>
    implements _$$DecompositionImplCopyWith<$Res> {
  __$$DecompositionImplCopyWithImpl(
    _$DecompositionImpl _value,
    $Res Function(_$DecompositionImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of Decomposition
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? gearId = null,
    Object? costEp = null,
    Object? costSsp = null,
    Object? resultMax = null,
    Object? resultMin = null,
    Object? result1 = freezed,
    Object? result2 = freezed,
    Object? result3 = freezed,
    Object? result4 = freezed,
    Object? result5 = freezed,
    Object? result6 = freezed,
    Object? result7 = freezed,
    Object? result8 = freezed,
  }) {
    return _then(
      _$DecompositionImpl(
        id:
            null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                    as String,
        gearId:
            null == gearId
                ? _value.gearId
                : gearId // ignore: cast_nullable_to_non_nullable
                    as String,
        costEp:
            null == costEp
                ? _value.costEp
                : costEp // ignore: cast_nullable_to_non_nullable
                    as int,
        costSsp:
            null == costSsp
                ? _value.costSsp
                : costSsp // ignore: cast_nullable_to_non_nullable
                    as int,
        resultMax:
            null == resultMax
                ? _value.resultMax
                : resultMax // ignore: cast_nullable_to_non_nullable
                    as int,
        resultMin:
            null == resultMin
                ? _value.resultMin
                : resultMin // ignore: cast_nullable_to_non_nullable
                    as int,
        result1:
            freezed == result1
                ? _value.result1
                : result1 // ignore: cast_nullable_to_non_nullable
                    as String?,
        result2:
            freezed == result2
                ? _value.result2
                : result2 // ignore: cast_nullable_to_non_nullable
                    as String?,
        result3:
            freezed == result3
                ? _value.result3
                : result3 // ignore: cast_nullable_to_non_nullable
                    as String?,
        result4:
            freezed == result4
                ? _value.result4
                : result4 // ignore: cast_nullable_to_non_nullable
                    as String?,
        result5:
            freezed == result5
                ? _value.result5
                : result5 // ignore: cast_nullable_to_non_nullable
                    as String?,
        result6:
            freezed == result6
                ? _value.result6
                : result6 // ignore: cast_nullable_to_non_nullable
                    as String?,
        result7:
            freezed == result7
                ? _value.result7
                : result7 // ignore: cast_nullable_to_non_nullable
                    as String?,
        result8:
            freezed == result8
                ? _value.result8
                : result8 // ignore: cast_nullable_to_non_nullable
                    as String?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$DecompositionImpl extends _Decomposition {
  const _$DecompositionImpl({
    required this.id,
    @JsonKey(name: "gear_ID") required this.gearId,
    @StringToIntConverter() @JsonKey(name: "cost_EP") required this.costEp,
    @StringToIntConverter() @JsonKey(name: "cost_SSP") required this.costSsp,
    @StringToIntConverter()
    @JsonKey(name: "result_max")
    required this.resultMax,
    @StringToIntConverter()
    @JsonKey(name: "result_min")
    required this.resultMin,
    @JsonKey(name: "result1") required this.result1,
    @JsonKey(name: "result2") required this.result2,
    @JsonKey(name: "result3") required this.result3,
    @JsonKey(name: "result4") required this.result4,
    @JsonKey(name: "result5") required this.result5,
    @JsonKey(name: "result6") required this.result6,
    @JsonKey(name: "result7") required this.result7,
    @JsonKey(name: "result8") required this.result8,
  }) : super._();

  factory _$DecompositionImpl.fromJson(Map<String, dynamic> json) =>
      _$$DecompositionImplFromJson(json);

  @override
  final String id;
  @override
  @JsonKey(name: "gear_ID")
  final String gearId;
  @override
  @StringToIntConverter()
  @JsonKey(name: "cost_EP")
  final int costEp;
  @override
  @StringToIntConverter()
  @JsonKey(name: "cost_SSP")
  final int costSsp;
  @override
  @StringToIntConverter()
  @JsonKey(name: "result_max")
  final int resultMax;
  @override
  @StringToIntConverter()
  @JsonKey(name: "result_min")
  final int resultMin;
  @override
  @JsonKey(name: "result1")
  final String? result1;
  @override
  @JsonKey(name: "result2")
  final String? result2;
  @override
  @JsonKey(name: "result3")
  final String? result3;
  @override
  @JsonKey(name: "result4")
  final String? result4;
  @override
  @JsonKey(name: "result5")
  final String? result5;
  @override
  @JsonKey(name: "result6")
  final String? result6;
  @override
  @JsonKey(name: "result7")
  final String? result7;
  @override
  @JsonKey(name: "result8")
  final String? result8;

  @override
  String toString() {
    return 'Decomposition(id: $id, gearId: $gearId, costEp: $costEp, costSsp: $costSsp, resultMax: $resultMax, resultMin: $resultMin, result1: $result1, result2: $result2, result3: $result3, result4: $result4, result5: $result5, result6: $result6, result7: $result7, result8: $result8)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DecompositionImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.gearId, gearId) || other.gearId == gearId) &&
            (identical(other.costEp, costEp) || other.costEp == costEp) &&
            (identical(other.costSsp, costSsp) || other.costSsp == costSsp) &&
            (identical(other.resultMax, resultMax) ||
                other.resultMax == resultMax) &&
            (identical(other.resultMin, resultMin) ||
                other.resultMin == resultMin) &&
            (identical(other.result1, result1) || other.result1 == result1) &&
            (identical(other.result2, result2) || other.result2 == result2) &&
            (identical(other.result3, result3) || other.result3 == result3) &&
            (identical(other.result4, result4) || other.result4 == result4) &&
            (identical(other.result5, result5) || other.result5 == result5) &&
            (identical(other.result6, result6) || other.result6 == result6) &&
            (identical(other.result7, result7) || other.result7 == result7) &&
            (identical(other.result8, result8) || other.result8 == result8));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    gearId,
    costEp,
    costSsp,
    resultMax,
    resultMin,
    result1,
    result2,
    result3,
    result4,
    result5,
    result6,
    result7,
    result8,
  );

  /// Create a copy of Decomposition
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DecompositionImplCopyWith<_$DecompositionImpl> get copyWith =>
      __$$DecompositionImplCopyWithImpl<_$DecompositionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DecompositionImplToJson(this);
  }
}

abstract class _Decomposition extends Decomposition {
  const factory _Decomposition({
    required final String id,
    @JsonKey(name: "gear_ID") required final String gearId,
    @StringToIntConverter() @JsonKey(name: "cost_EP") required final int costEp,
    @StringToIntConverter()
    @JsonKey(name: "cost_SSP")
    required final int costSsp,
    @StringToIntConverter()
    @JsonKey(name: "result_max")
    required final int resultMax,
    @StringToIntConverter()
    @JsonKey(name: "result_min")
    required final int resultMin,
    @JsonKey(name: "result1") required final String? result1,
    @JsonKey(name: "result2") required final String? result2,
    @JsonKey(name: "result3") required final String? result3,
    @JsonKey(name: "result4") required final String? result4,
    @JsonKey(name: "result5") required final String? result5,
    @JsonKey(name: "result6") required final String? result6,
    @JsonKey(name: "result7") required final String? result7,
    @JsonKey(name: "result8") required final String? result8,
  }) = _$DecompositionImpl;
  const _Decomposition._() : super._();

  factory _Decomposition.fromJson(Map<String, dynamic> json) =
      _$DecompositionImpl.fromJson;

  @override
  String get id;
  @override
  @JsonKey(name: "gear_ID")
  String get gearId;
  @override
  @StringToIntConverter()
  @JsonKey(name: "cost_EP")
  int get costEp;
  @override
  @StringToIntConverter()
  @JsonKey(name: "cost_SSP")
  int get costSsp;
  @override
  @StringToIntConverter()
  @JsonKey(name: "result_max")
  int get resultMax;
  @override
  @StringToIntConverter()
  @JsonKey(name: "result_min")
  int get resultMin;
  @override
  @JsonKey(name: "result1")
  String? get result1;
  @override
  @JsonKey(name: "result2")
  String? get result2;
  @override
  @JsonKey(name: "result3")
  String? get result3;
  @override
  @JsonKey(name: "result4")
  String? get result4;
  @override
  @JsonKey(name: "result5")
  String? get result5;
  @override
  @JsonKey(name: "result6")
  String? get result6;
  @override
  @JsonKey(name: "result7")
  String? get result7;
  @override
  @JsonKey(name: "result8")
  String? get result8;

  /// Create a copy of Decomposition
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DecompositionImplCopyWith<_$DecompositionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
